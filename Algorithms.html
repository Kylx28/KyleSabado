<html>
  <head>
    <title> Searching and Sorting </title>
    <link rel="stylesheet" href="style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
  </head>
  <body>
      <section class="header">
          <nav>
              <a href="index.html">Kyle Sabado</a>
              <div class ="Brebeuf">
                  <p>&nbsp / Brebeuf Student</p>
              </div>
              <div class="links">
                  <ul>
                      <li><a href="Arrays.html">Arrays and ArrayLists</a></li>
                      <li><a href="ClassesAndObjects.html">Classes and Objects</a></li>
                      <li><a href="Recursion.html">Recursion</a></li>
                      <li><a href="Algorithms.html">Algorithms</a></li>
                      <li><a href="Polymorphism.html">Polymorphism</a></li>
                  </ul>
              </div>
          </nav>
      </section>
      <div class = "section">
          <h2>Searching and Sorting</h2>
      </div>
      <div class = "rectangle4">
        <p><b>Searching</b> algorithms are used to retrieve data stored within a data structure.
            <br><br>
            <b>Sorting</b> algorithms are used to arrange information stored within a data structure in a particular way. Examples include sorting in an increasing order, decreasing order, or alphabetically.
        </p>
      </div>
      <div class = "instructions">
          <h1>Searching</h1>
          <p>There are two searching algorithms we learned in class.
              <br><b>Linear Search</b> and <b>Binary Search</b><br><br>
          </p>
          <p><h2>Linear Search:</h2>
             Linear search is an algorithm that sequentially checks each element in the list until the correct element has been found.
             <br>The linear search algorithm takes in an array of size n, and a key. A for loop will loop through each element in the array
             <br>until the key has been found, or until its get to the end. If it does not find the key, -1 will be returned. If it does, 
             <br>the index of the key will be returned.
            <br><br><h3>Implemetation of Linear Search</h3>
            <br><img class ="search-img" src="linearSearch.png" alt="linear search">
            <br><br>
            Just like the name suggests, the <b>worst case</b> time complexity for linear search is O(n), because for an input size of n, the for loop will iterate n times. 
            <br>The <b>best case</b> time complexity is O(1), if the key is in the beginning of the array.
            <br><br>
            <h2>Binary Search:</h2>
            Binary search is an algorithm that is used to search for an element in a sorted array by continually dividing the array into halfs.
            <br>Since the array is sorted, we can compare the key to the middle element which will tell us which half the key is in. This checks is repeatedly
            <br>done until the index of the key is found, or if the key does not exist in the array.
            <br><br><h3>Implemetation of Binary Search</h3>
            There are two ways of implementing binary search. It can be done iteratively, or recursively.
            <br>The key is compared with the middle element, and if they are equal, the index of the middle element is returned.
            <br>If the key is less than the middle, the end of the array becomes the middle - 1. If the key is greater than the middle,
            <br>the start of the array becomes the middle + 1. Then, this is repeated until the key is found using a loop, or using recursion.
            <br><br>
            <h3>Iterative Binary Search:</h3>
            <br><img class ="search-img" src="binarySearchI.png" alt="binary search I">
            <br><br><br>
            <h3>Recursive Binary Search:</h3>
            <br><img class ="search-img" src="binarySearchR.png" alt="binary search R">
            <br><br>
            The <b>worst case</b> time complexity is O(logn).
            <br><br>After some number (x) of iterations, the length of the array is 1.
            <br>After each iteration, the array is divided in half. Thus, the length of the array after x iterations is
            <br>n / 2<sup>x</sup>, where n is the length of the array. But, after x iterations, the length is 1. Therefore,
            <br>n / 2<sup>x</sup> = 1
            <br>n = 2<sup>x</sup>
            <br>x = log<sub>2</sub>n
            <br><br>The <b>best case</b> time complexity is O(1), where the middle element is the key.
            <br><br>Binary search is much faster than linear search, because as the input size grows, linear growth is much
            <br>faster than logarithmic growth, meaning the run time of linear search is much larger as well.
            <br>The caveat is that the array must be sorted before hand. Sorting an array also has a computational complexity.
            <br><br>
          </p>
          <h1>Sorting</h1>
          <p>There are five sorting algorithms we learned in class.
              <br><b>Selection Sort</b>, <b>Insertion Sort</b>, <b>Bubble Sort</b>, <b>Quick Sort</b>, and <b>Merge Sort</b>.
              <br><br>In several of these sorting routines, an element at one index must be swapped another index. This is done by creating an temporary
              <br>variable in order to store the value of one element, setting the value of that element to another, and setting the other element
              <br>to the temporary variable. This effectively swaps the values between the two elements.
              <br><br>
              <h3>Swap Method Implemetation</h3>
              <img class ="search-img" src="swap.png" alt="swap">
              <br><br>This method will be used in several sorting algorithms.
              <br><br>
              <h2>Selection Sort</h2>
              Selection sort works by iterating through the array to find the smallest element and moving it the front. The array is separated
              <br>into a sorted and an unsorted part. In each iteration, the minimum element from the unsorted array moves to the sorted array.
              <br><br>
              <h3>Implemetation</h3>
              <img class ="search-img" src="selection_sort.png" alt="selection_sort">
              <br><br>
              The first for loop keeps track of the subarray of sorted elements, while the nested array iterates through the unsorted part of the array.
              <br>In each iteration of the nested for loop, a comparison is made between the current index every other index until its finds something
              <br>that is less than the value at the current index. If this is the case, the two elements swap places. The i index increments, and the
              <br>process is repeated until the array is sorted.
              <br><br>
              The <b>worst case</b> time complexity is <b>O(n<sup>2</sup>)</b>.
              <br><br>Actually, the time complexity of selection sort is always <b>O(n<sup>2</sup>)</b>.
              <br><br>
              Selection sort is a sort-in-place algorithm, meaning the algorithm does not require any auxiliary arrays.
              <br><br> 
              <h2>Bubble Sort</h2>
              Bubble sort works by comparing adjacent elements and swapping them if the current element is greater than the adjacent one.
              <br><br>
              <h3>Implemetation</h3>
              <img class ="search-img" src="bubble_sort.png" alt="bubble_sort">
              <br><br>This algorithm can be made more efficient by breaking the loop when elements are no longer being swapped, meaning the array is sorted.
              <br><br>
              <h3>Optimized Bubble Sort</h3>
              <img class ="search-img" src="bubble_sort2.png" alt="bubble_sort2">
              <br><br>The time complexity of bubble sort is <b>O(n<sup>2</sup>)</b>. Even with the optimization, it still has quadratic time complexity.
              <br><br>
              Bubble sort is a sort-in-place algorithm.
              <h2>Insertion Sort</h2>
              Insertion sort works by comparing each element to the elements on its left. The current element is inserted into its correct position
              <br>in the array. During the algorithm, the array will form sorted and unsorted sections.
              <br><br>
              <h3>Implemetation</h3>
              <img class ="search-img" src="insertion_sort.png" alt="insertion_sort">
              <br><br>
              Starting at the beginning of the array, the first element is on its own, so its sorted. The next element is compared with the element in the
              <br>sorted array, at inserted at its correct position. Each subsequent element is compared with each element in the sorted array, and placed
              <br>where it should belong, until entire array is sorted.
              <br><br>
              The <b>worst case</b> time complexity of insertion sort is <b>O(n<sup>2</sup>)</b>.
              <br><br>
              The <b>best case</b> time complexity of insertion sort is <b>O(n)</b>, which is when the array is already sorted.
              <br><br>
              Insertion sort is a sort-in-place algorithm.
              <br><br>
              <h2>Quick Sort</h2>
              Quick Sort is a recursive, divide and conquer algorithm, in which the sorting problem is broken down into sub problems which have simple solutions.
              <br>An element in the array is picked as the pivot, and partitions of the array are created around the pivot. Any element can be picked as the pivot, but
              <br>in this case we're going to use the last element. This algorithm requires two methods, a partition method, and a recursive method.
              <br><br>
              <h3>Partition Implemetation</h3>
              <img class ="search-img" src="partition.png" alt="partition">
              <br><br>Once this method runs completely, we are 100% certain that the pivot was moved to its correct spot. Now, we recursively call the partition function on the subarrays
              <br>left and right of the pivot. After this, the array will be completely sorted.
              <br><br>
              <h3>Quick Sort Implemetation</h3>
              <img class ="search-img" src="quick_sort.png" alt="quick_sort">
              <br><br>
              The <b>worst case</b> time complexity of this algorithm is <b>O(n<sup>2</sup>)</b>.
              <br><br>
              The <b>best case</b> time complexity is <b>O(nlogn)</b>, when the pivot is always the middle element.
              <br><br>
              Quick Sort is also a sort-in-place algorithm.
              <br><br>
              <h2>Merge Sort</h2>
              Merge sort another divide and conquer algorithm like quick sort. The array is divided into many halfs until each element has its own array. The halfs are sorted
              <br>and merged into one array using another method called merge(). Like quick sort, merge sort is a recursive algorithm.
              <br><br>
              <h3>merge() Implemetation</h3>
              <img class ="search-img" src="merge.png" alt="merge">
              <br><br>
              The merge() method compares two different elements in two different arrays at the same index and inserts them in their correct order. This comparison is done
              <br>using inside of a while loop, and if there are any left over elements, two separate while loops add them to the array in their proper order.
              <br><br>
              <h3>Merge Sort Implementation</h3>
              <img class ="search-img" src="merge_sort.png" alt="merge_sort">
              <br><br>
              The mergeSort() method recusively breaks up the given array into various single sized arrays.
              <br><br>
              The time complexity of merge sort is always <b>O(nlogn)</b>.
              <br><br>
              The space complexity of merge sort is <b>O(n)</b>, meaning the memory use increases linearly as the input size increases. 
              <br><br>
              Merge sort is not a sort-in-place algorithm.
          </p>
      </div>
  </body>
</html>
